// generate shift tables for perforimg non-integer bin shifting on FFT data
//
// ver1
// darrell.barrell

cmd = "cont";

// generate table of fft of various non-integer freqss
//


// the continuous time fourier transform of non integer bin freqs is given by
// (ignoring freq folding at DC or nyquist)
//
// bin : integer bin position (-w to w) to find coefficient
// t : time
// frac : fractional frequency (assume -.5 to .5)
//
// coeff(frac, bin) = integral(t=0..1, exp(i.2pi.t.frac) . exp(-i.2pi.t.bin) . dt)
//     = integral(w=0..1, exp(i.2pi.t.(frac-bin)) . dt)
//     = 1/(i.2pi.(frac-bin)) (exp(i.2pi.(frac-bin) - exp(0))
//     = (exp(i.2pi.frac)-1)/(i.2pi.(frac-bin))
//


// data either side of centre to save (mul's per bin is w*2+1)
w = 2;

// number of fraction bits to generate for table
bits = 6;

// window to use when copying bins
ww = -w:w;

// fractional freq's to generate, fraction goes 0 to .5 and then -.5 to 0 (as though it is signed)
t = 2^(bits-1);
frac = .5*[0:t-1 -t:0]/t;

// there are 2 ways to generate coefficients... using the continuous time
// integral or FFT on an actual generated wave
//
// The differences are:
// 1. limits of "t" (time) are actually 0..(fft_len-1)/fft_len vs 0 to 1
// 2. discrete sum is different to continuous time integral
// 3. slight folding effects in the fft version
//
// The 2 converge as the number of discrete points becomes large
//
if cmd=='cont'
    // continuous time
    f_i = 1;
    fxx = [];
    for f = frac
        den = %i*2*%pi*(f-ww);
        t = find(abs(den) > 1e-12);
        res = ones(1, length(den))*1;
        res(t) = (exp(%i*2*%pi*f)-1) ./ den(t);
        fxx(:, f_i) = res(:);
        f_i = f_i+1;
    end
else
    // discrete sum

    // size of reference fft
    n = 2^10;

    // period of reference
    per = n/4;

    // output references
    fxx = zeros(length(ww), length(frac));

    for a = 1:length(frac)
        // generate fractional period
        x = cos(rng(0, 2*%pi*(per+frac(a)), n));
        xx = rfft(x);
        fxx(:, a) = matrix(xx(per+1+ww), -1);
    end
end

clf
subplot(211);
surf(abs(fxx));
subplot(212);
surf(angle(fxx));

ans = input("\nenter y to generate code", "string");
if ans ~= "y"
  printf("done, no code written\n");
  return
end


printf("Generating code\n");

[fd, err] = mopen( "fft_frac_shift.h", "w");

// the array width is made one bigger than 2*W so that it has an even number
// of elements per per row (maybe helpful to optimizing SSE)

fprintf(fd, "// file generated by gen_fft_shift_table.sci (ver1, darrell.barrell)\n");
fprintf(fd, "#ifndef _FFT_FRAC_SHIFT_H_\n");
fprintf(fd, "#define _FFT_FRAC_SHIFT_H_\n");
fprintf(fd, "#include ""cplxf.h""\n");
fprintf(fd, "#include ""FixPoint.h""\n");
fprintf(fd, "#include ""VecSlice.h""\n");
fprintf(fd, "namespace FFTFracShift\n");
fprintf(fd, "{\n");
fprintf(fd, "enum {\n");
fprintf(fd, "    BITS=%d, // shift fraction bits\n", bits);
fprintf(fd, "    N=%d,   // number of shift tables\n", 2^bits);
fprintf(fd, "    W=%d,   // number of bins per shift table\n", length(ww));
fprintf(fd, "    W_OFFS=%d //table offset when shifting from centre freq\n", w);
fprintf(fd, "};\n");
fprintf(fd, "extern cplxf coeff[%d][%d];\n", length(frac), length(ww)+1);
fprintf(fd, "\n");
fprintf(fd, "\n");
fprintf(fd, "template <int CHANNELS, class DST_BIN, class MULT>\n");
fprintf(fd, "	inline void add(\n");
fprintf(fd, "		const VecPtr<cplxf, CHANNELS>& dst,// dst data\n");
fprintf(fd, "		const DST_BIN& dst_bin,            // position (float or fixpoint)\n");
fprintf(fd, "		const MULT& mult                   // multiply\n");
fprintf(fd, "	)\n");
fprintf(fd, "// note that output is not reflected at DC or nyquist\n");
fprintf(fd, "// normal way to call is\n");
fprintf(fd, "//   FixPoint<what ever> dst_bin = <what ever>;\n");
fprintf(fd, "//   VecPtr<cplxf, CHANNELS> dst = <where ever>;\n");
fprintf(fd, "//   int src_bin = <where ever>;\n");
fprintf(fd, "//   FFTFracShift::add(dst, dst_bin, phase_correct(dst_bin-src_bin) * src(src_bin));\n");
fprintf(fd, "{\n");
fprintf(fd, "    FixPoint<BITS> fix_dst_bin;\n");
fprintf(fd, "    fix_dst_bin.setClosest(dst_bin);\n");
fprintf(fd, "    cplxf* c = coeff[fix_dst_bin.getFracRaw()];\n");
fprintf(fd, "    int dst_bin_r = fix_dst_bin.getRound()-%d;\n", w);
for a=0:w*2
  fprintf(fd, "    dst[dst_bin_r++] += c[%d] * mult;\n", a);
end
fprintf(fd, "}\n");


fprintf(fd, "};\n");
fprintf(fd, "#endif\n");
mclose(fd);

[fd, err] = mopen("fft_frac_shift.cpp", "w");
fprintf(fd, "// file generated by gen_fft_shift_table.sci (ver1, darrell.barrell)\n");
fprintf(fd, "#include <StdAfx.h>\n");
fprintf(fd, "#include ""fft_frac_shift.h""\n");
fprintf(fd, "namespace FFTFracShift\n");
fprintf(fd, "{\n");
fprintf(fd, "  #define A(r, i) cplxf((float)r, (float)i)\n");
fprintf(fd, "  cplxf coeff[%d][%d] = {\n", length(frac), length(ww)+1);
for a = 1:length(frac)
  fprintf(fd, "    /*%d: %f*/{", a-1, frac(a));
  for b = 1:length(ww)
    fprintf(fd, "A(%f, %f), ", real(fxx(b, a)), imag(fxx(b, a)));
  end
  fprintf(fd, "A(0,0) }"); // pad element
  if a ~= length(frac) then
    fprintf(fd, ",");
  end
  fprintf(fd, "\n");
end
fprintf(fd, "  };\n");
fprintf(fd, "};\n");
mclose(fd);

