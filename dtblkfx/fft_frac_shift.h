// file generated by gen_fft_shift_table.sci (ver1, darrell.barrell)
#ifndef _FFT_FRAC_SHIFT_H_
#define _FFT_FRAC_SHIFT_H_
#include "cplxf.h"
#include "FixPoint.h"
#include "VecSlice.h"
namespace FFTFracShift
{
enum {
    BITS=6, // shift fraction bits
    N=64,   // number of shift tables
    W=5,   // number of bins per shift table
    W_OFFS=2 //table offset when shifting from centre freq
};
extern cplxf coeff[65][6];


template <int CHANNELS, class DST_BIN, class MULT>
	inline void add(
		const VecPtr<cplxf, CHANNELS>& dst,// dst data
		const DST_BIN& dst_bin,            // position (float or fixpoint)
		const MULT& mult                   // multiply
	)
// note that output is not reflected at DC or nyquist
// normal way to call is
//   FixPoint<what ever> dst_bin = <what ever>;
//   VecPtr<cplxf, CHANNELS> dst = <where ever>;
//   int src_bin = <where ever>;
//   FFTFracShift::add(dst, dst_bin, phase_correct(dst_bin-src_bin) * src(src_bin));
{
    FixPoint<BITS> fix_dst_bin;
    fix_dst_bin.setClosest(dst_bin);
    cplxf* c = coeff[fix_dst_bin.getFracRaw()];
    int dst_bin_r = fix_dst_bin.getRound()-2;
    dst[dst_bin_r++] += c[0] * mult;
    dst[dst_bin_r++] += c[1] * mult;
    dst[dst_bin_r++] += c[2] * mult;
    dst[dst_bin_r++] += c[3] * mult;
    dst[dst_bin_r++] += c[4] * mult;
}
};
#endif
