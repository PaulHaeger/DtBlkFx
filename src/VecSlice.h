//DO NOT MODIFY! this file generated by preprocess.pl from VecSlice_.h
#ifndef _DT_VEC_SLICE_H_
#define _DT_VEC_SLICE_H_



#include "misc_stuff.h"

//-------------------------------------------------------------------------------------------------
template <class T, int CHANNELS> struct VecSlice;
template <class T, int CHANNELS> struct Slice;

//-------------------------------------------------------------------------------------------------
template <class T, int CHANNELS> struct Slice
// a slice is similar to an array except that operators affect all elements
{
	T data[CHANNELS];

	// BE CAREFUL with this: break const to produce faster code
	T& val_(int ch) const { return (const_cast<Slice&>(*this)).data[ch]; }

	Slice() {}

	// copy from array
	template <class T2> Slice(const Array<T2, CHANNELS>& src) { for(int i = 0; i < CHANNELS; i++) data[i] = src[i]; }

	// copy from a VecSlice
	template <class T2> Slice(const VecSlice<T2, CHANNELS>& src) { SliceAssign(*this, src); }

	// copy from another type of Slice
	template <class T2> Slice(const Slice<T2, CHANNELS>& src) { SliceAssign(*this, src); }

	// try to copy from something else (e.g. set all elements to the same value)
	template <class T2> Slice(const T2& src) { SliceAssign(*this, src); }

	//declare all operator assignments
	template <class B> Slice& operator += (const B& b) { AddAssign(*this, b); return *this; }
	template <class B> Slice& operator -= (const B& b) { SubtractAssign(*this, b); return *this; }
	template <class B> Slice& operator *= (const B& b) { MultiplyAssign(*this, b); return *this; }
	template <class B> Slice& operator /= (const B& b) { DivideAssign(*this, b); return *this; }
	template <class B> Slice& operator <<= (const B& b) { LeftShiftAssign(*this, b); return *this; }
	template <class B> Slice& operator >>= (const B& b) { RightShiftAssign(*this, b); return *this; }
	template <class B> Slice& operator %= (const B& b) { ModuloAssign(*this, b); return *this; }
	template <class B> Slice& operator |= (const B& b) { OrAssign(*this, b); return *this; }
	template <class B> Slice& operator &= (const B& b) { AndAssign(*this, b); return *this; }
	template <class B> Slice& operator ^= (const B& b) { XorAssign(*this, b); return *this; }

	// return a particular channel-element of the slice (not really const-correct)
	T operator [] (int ch) const { return data[ch]; }
	T& operator [] (int ch) { return data[ch]; }

};

//-------------------------------------------------------------------------------------------------
template <class T, int CHANNELS> struct VecPtr
// VecPtr is an array of pointers
//
// main purpose is to provide slices into the vectors - a slice is all channel pointers offset by
// the some number
//
{
	T* data[CHANNELS];

	VecPtr() {}

	// expect "T2" to be T* or compatible
	template <class T2> VecPtr(Array<T2, CHANNELS>& src, int offs = 0) { VecPtrAssign(*this, src, offs); }
		//{ for(int i = 0; i < CHANNELS; i++) data[i] = src.data[i]+offs; }

	// offset from another VecPtr (const_cast not actually needed)
	template <class T2> VecPtr(const VecPtr<T2, CHANNELS>& src, int offs) { VecPtrAssign(*this, const_cast<VecPtr<T2, CHANNELS>& >(src), offs); }
		//{ for(int i = 0; i < CHANNELS; i++) data[i] = src.data[i]+offs; }

	VecSlice<T, CHANNELS> GetVecSlice(int offs) const;

	// [] returns a vector slice (same as .GetVecSlice(offs) )
	VecSlice<T, CHANNELS> operator[] (int offs) const { return GetVecSlice(offs); }

	// () operator returns a particular element (same as doing [offs][ch])
	T& operator() (int offs, int ch) { return data[ch][offs]; }
	T operator() (int offs, int ch) const { return data[ch][offs]; }
};

//-------------------------------------------------------------------------------------------------
template <class T, int CHANNELS> struct VecSlice : public VecPtr<T, CHANNELS>
// VecSlice<> is a dereferrenced slice from VecPtr<>
// the difference is that all operators work on the VecSlice because they reference or modify
// whatever we're pointing at
{
	typedef VecPtr<T, CHANNELS> base;

	// BE CAREFUL with this: break const to produce faster code
	T& val_(int ch) const { return *base::data[ch]; }

	// 
	VecSlice(const VecSlice& src): VecPtr<T, CHANNELS>(src) { }

	template <class T2> VecSlice(const VecPtr<T2, CHANNELS>& src, int offs) : VecPtr<T, CHANNELS>(src, offs) {}

	// NOTE: we behave deref'd: assignment changes what we point at
	// use a non-member function because of problems with declaring partially specialized templated methods
	VecSlice& operator = (const VecSlice& src) { VecSliceAssign(*this, src); return *this; }
	template <class T2> VecSlice& operator = (const T2& src) { VecSliceAssign(*this, src); return *this; }

	//declare all operator assignments
	template <class B> VecSlice& operator += (const B& b) { AddAssign(*this, b); return *this; }
	template <class B> VecSlice& operator -= (const B& b) { SubtractAssign(*this, b); return *this; }
	template <class B> VecSlice& operator *= (const B& b) { MultiplyAssign(*this, b); return *this; }
	template <class B> VecSlice& operator /= (const B& b) { DivideAssign(*this, b); return *this; }
	template <class B> VecSlice& operator <<= (const B& b) { LeftShiftAssign(*this, b); return *this; }
	template <class B> VecSlice& operator >>= (const B& b) { RightShiftAssign(*this, b); return *this; }
	template <class B> VecSlice& operator %= (const B& b) { ModuloAssign(*this, b); return *this; }
	template <class B> VecSlice& operator |= (const B& b) { OrAssign(*this, b); return *this; }
	template <class B> VecSlice& operator &= (const B& b) { AndAssign(*this, b); return *this; }
	template <class B> VecSlice& operator ^= (const B& b) { XorAssign(*this, b); return *this; }
	
	// return particular channel of the slice
	T operator [] (int ch) const { return *base::data[ch]; }
	T& operator [] (int ch) { return *base::data[ch]; }

	// use () operator go move to other slices above or below this slice
	VecSlice operator() (int offs) const { return base::GetVecSlice(offs); }

protected:
	// VecSlices can *only* come out of a VecPtr
	//friend VecPtr; // g++ complains
	VecSlice() {}
};

template <class T, int CHANNELS> VecSlice<T, CHANNELS> VecPtr<T, CHANNELS>::GetVecSlice(int offs) const
	{ return VecSlice<T, CHANNELS>(*this, offs); }

template <class T, int CHANNELS> Slice<T, CHANNELS> ToSlice(const VecSlice<T, CHANNELS>& src)
	{ return Slice<T, CHANNELS>(src); }


// handle reversed non-slice argument
template<class A, class T, int CHANNELS> inline bool isIdentical(const A& a, const Slice<T, CHANNELS>& b)
	{ return isIdentical(b, a); }
template<class A, class T, int CHANNELS> inline Slice<bool, CHANNELS> operator == (const A& a, const Slice<T, CHANNELS>& b)
	{ return b == a; }
template<class A, class T, int CHANNELS> inline Slice<bool, CHANNELS> operator != (const A& a, const Slice<T, CHANNELS>& b)
	{ return b != a; }
template<class A, class T, int CHANNELS> inline bool isIdentical(const A& a, const VecSlice<T, CHANNELS>& b)
	{ return isIdentical(b, a); }
template<class A, class T, int CHANNELS> inline Slice<bool, CHANNELS> operator == (const A& a, const VecSlice<T, CHANNELS>& b)
	{ return b == a; }
template<class A, class T, int CHANNELS> inline Slice<bool, CHANNELS> operator != (const A& a, const VecSlice<T, CHANNELS>& b)
	{ return b != a; }


//-------------------------------------------------------------------------------------------------
template <class T, int CHANNELS>
	inline std::ostream& operator << (std::ostream& o, const Slice<T, CHANNELS>& s)
{
	//TODO
	o << "[" << s[0];
	for(int i = 1; i < CHANNELS; i++) o << ", " << s[i];
	return o << "]";
}
template <class T, int CHANNELS>
	inline std::ostream& operator << (std::ostream& o, const VecSlice<T, CHANNELS>& vs)
		{ return o << ToSlice(vs); }

//-------------------------------------------------------------------------------------------------
// now for lots of inlined code
//

//---------------------------------------------------------------------------------------------
template <class T, class T2/*Array or VecPtr*/>
	inline void VecPtrAssign(VecPtr<T, 1>& dst, T2& src, int offs)
// force a const (removal) cast to handle Array<T*> that returns const pointer reference
{
	dst.data[0] = src.data[0]+offs;
}

//---------------------------------------------------------------------------------------------
template <class T> inline Slice<T, 1> ToSlice(
	const T& arg_0
)
// take a variable number of arguments to generate a Slice
{
	Slice<T, 1> r;
	r[0] = arg_0;
	return r;
}


//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void SliceAssign(Slice<T, 1>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 1> operator- (const Slice<T, 1>& src)
// return negative of all elements
{
	Slice<T, 1> r;
	r[0] = -src.val_(0);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 1>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 1> operator == (const Slice<T, 1>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 1> operator != (const Slice<T, 1>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator == (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator != (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 1>& dst, const Slice<T2, 1>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 1>& a, const Slice<T2, 1>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator == (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator != (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(Slice<T, 1>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	//dst += Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator + (const Slice<T, 1>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator + (const A& a, const Slice<T, 1>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a + b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator + (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise +
{
	Slice<T, 1> r;
	r[0] = a.val_(0) + b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator + (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise +
{
	Slice<T, 1> r;
	r[0] = a.val_(0) + b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(Slice<T, 1>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	//dst -= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator - (const Slice<T, 1>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator - (const A& a, const Slice<T, 1>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a - b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator - (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise -
{
	Slice<T, 1> r;
	r[0] = a.val_(0) - b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator - (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise -
{
	Slice<T, 1> r;
	r[0] = a.val_(0) - b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(Slice<T, 1>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	//dst *= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator * (const Slice<T, 1>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator * (const A& a, const Slice<T, 1>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a * b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator * (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise *
{
	Slice<T, 1> r;
	r[0] = a.val_(0) * b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator * (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise *
{
	Slice<T, 1> r;
	r[0] = a.val_(0) * b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(Slice<T, 1>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	//dst /= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator / (const Slice<T, 1>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator / (const A& a, const Slice<T, 1>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a / b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator / (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise /
{
	Slice<T, 1> r;
	r[0] = a.val_(0) / b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator / (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise /
{
	Slice<T, 1> r;
	r[0] = a.val_(0) / b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(Slice<T, 1>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	//dst <<= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator << (const Slice<T, 1>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator << (const A& a, const Slice<T, 1>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a << b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator << (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise <<
{
	Slice<T, 1> r;
	r[0] = a.val_(0) << b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator << (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise <<
{
	Slice<T, 1> r;
	r[0] = a.val_(0) << b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(Slice<T, 1>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	//dst >>= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator >> (const Slice<T, 1>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator >> (const A& a, const Slice<T, 1>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a >> b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator >> (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise >>
{
	Slice<T, 1> r;
	r[0] = a.val_(0) >> b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator >> (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise >>
{
	Slice<T, 1> r;
	r[0] = a.val_(0) >> b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(Slice<T, 1>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	//dst %= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator % (const Slice<T, 1>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator % (const A& a, const Slice<T, 1>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a % b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator % (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise %
{
	Slice<T, 1> r;
	r[0] = a.val_(0) % b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator % (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise %
{
	Slice<T, 1> r;
	r[0] = a.val_(0) % b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(Slice<T, 1>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	//dst |= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator | (const Slice<T, 1>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator | (const A& a, const Slice<T, 1>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a | b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator | (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise |
{
	Slice<T, 1> r;
	r[0] = a.val_(0) | b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator | (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise |
{
	Slice<T, 1> r;
	r[0] = a.val_(0) | b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(Slice<T, 1>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	//dst &= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator & (const Slice<T, 1>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator & (const A& a, const Slice<T, 1>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a & b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator & (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise &
{
	Slice<T, 1> r;
	r[0] = a.val_(0) & b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator & (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise &
{
	Slice<T, 1> r;
	r[0] = a.val_(0) & b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(Slice<T, 1>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	//dst ^= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator ^ (const Slice<T, 1>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator ^ (const A& a, const Slice<T, 1>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a ^ b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator ^ (const Slice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise ^
{
	Slice<T, 1> r;
	r[0] = a.val_(0) ^ b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator ^ (const Slice<T, 1>& a, const Slice<T2, 1>& b)
// element wise ^
{
	Slice<T, 1> r;
	r[0] = a.val_(0) ^ b.val_(0);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void VecSliceAssign(VecSlice<T, 1>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 1> operator- (const VecSlice<T, 1>& src)
// return negative of all elements
{
	Slice<T, 1> r;
	r[0] = -src.val_(0);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 1>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 1> operator == (const VecSlice<T, 1>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 1> operator != (const VecSlice<T, 1>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator == (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator != (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator == (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 1> operator != (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(VecSlice<T, 1>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	//dst += Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator + (const VecSlice<T, 1>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator + (const A& a, const VecSlice<T, 1>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a + b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator + (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise +
{
	Slice<T, 1> r;
	r[0] = a.val_(0) + b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator + (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise +
{
	Slice<T, 1> r;
	r[0] = a.val_(0) + b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(VecSlice<T, 1>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	//dst -= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator - (const VecSlice<T, 1>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator - (const A& a, const VecSlice<T, 1>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a - b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator - (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise -
{
	Slice<T, 1> r;
	r[0] = a.val_(0) - b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator - (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise -
{
	Slice<T, 1> r;
	r[0] = a.val_(0) - b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(VecSlice<T, 1>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	//dst *= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator * (const VecSlice<T, 1>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator * (const A& a, const VecSlice<T, 1>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a * b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator * (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise *
{
	Slice<T, 1> r;
	r[0] = a.val_(0) * b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator * (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise *
{
	Slice<T, 1> r;
	r[0] = a.val_(0) * b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(VecSlice<T, 1>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	//dst /= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator / (const VecSlice<T, 1>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator / (const A& a, const VecSlice<T, 1>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a / b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator / (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise /
{
	Slice<T, 1> r;
	r[0] = a.val_(0) / b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator / (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise /
{
	Slice<T, 1> r;
	r[0] = a.val_(0) / b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(VecSlice<T, 1>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	//dst <<= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator << (const VecSlice<T, 1>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator << (const A& a, const VecSlice<T, 1>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a << b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator << (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise <<
{
	Slice<T, 1> r;
	r[0] = a.val_(0) << b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator << (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise <<
{
	Slice<T, 1> r;
	r[0] = a.val_(0) << b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(VecSlice<T, 1>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	//dst >>= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator >> (const VecSlice<T, 1>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator >> (const A& a, const VecSlice<T, 1>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a >> b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator >> (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise >>
{
	Slice<T, 1> r;
	r[0] = a.val_(0) >> b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator >> (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise >>
{
	Slice<T, 1> r;
	r[0] = a.val_(0) >> b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(VecSlice<T, 1>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	//dst %= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator % (const VecSlice<T, 1>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator % (const A& a, const VecSlice<T, 1>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a % b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator % (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise %
{
	Slice<T, 1> r;
	r[0] = a.val_(0) % b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator % (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise %
{
	Slice<T, 1> r;
	r[0] = a.val_(0) % b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(VecSlice<T, 1>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	//dst |= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator | (const VecSlice<T, 1>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator | (const A& a, const VecSlice<T, 1>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a | b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator | (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise |
{
	Slice<T, 1> r;
	r[0] = a.val_(0) | b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator | (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise |
{
	Slice<T, 1> r;
	r[0] = a.val_(0) | b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(VecSlice<T, 1>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	//dst &= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator & (const VecSlice<T, 1>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator & (const A& a, const VecSlice<T, 1>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a & b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator & (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise &
{
	Slice<T, 1> r;
	r[0] = a.val_(0) & b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator & (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise &
{
	Slice<T, 1> r;
	r[0] = a.val_(0) & b.val_(0);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(VecSlice<T, 1>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	//dst ^= Slice<B, 1>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 1> operator ^ (const VecSlice<T, 1>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 1> r;
	r[0] = a.val_(0) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 1> operator ^ (const A& a, const VecSlice<T, 1>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 1> r;
	r[0] = a ^ b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 1>& dst, const VecSlice<T2, 1>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator ^ (const VecSlice<T, 1>& a, const VecSlice<T2, 1>& b)
// element wise ^
{
	Slice<T, 1> r;
	r[0] = a.val_(0) ^ b.val_(0);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 1>& dst, const Slice<T2, 1>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 1> operator ^ (const VecSlice<T, 1>& a, const Slice<T2, 1>& b)
// element wise ^
{
	Slice<T, 1> r;
	r[0] = a.val_(0) ^ b.val_(0);
	return r;
}

//---------------------------------------------------------------------------------------------
template <class T, class T2/*Array or VecPtr*/>
	inline void VecPtrAssign(VecPtr<T, 2>& dst, T2& src, int offs)
// force a const (removal) cast to handle Array<T*> that returns const pointer reference
{
	dst.data[0] = src.data[0]+offs;
	dst.data[1] = src.data[1]+offs;
}

//---------------------------------------------------------------------------------------------
template <class T> inline Slice<T, 2> ToSlice(
	const T& arg_0,
	const T& arg_1
)
// take a variable number of arguments to generate a Slice
{
	Slice<T, 2> r;
	r[0] = arg_0;
	r[1] = arg_1;
	return r;
}


//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void SliceAssign(Slice<T, 2>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
	dst[1] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 2> operator- (const Slice<T, 2>& src)
// return negative of all elements
{
	Slice<T, 2> r;
	r[0] = -src.val_(0);
	r[1] = -src.val_(1);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 2>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b &&
	a.val_(1) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 2> operator == (const Slice<T, 2>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b,
		a.val_(1) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 2> operator != (const Slice<T, 2>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b,
		a.val_(1) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator == (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator != (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 2>& dst, const Slice<T2, 2>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 2>& a, const Slice<T2, 2>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator == (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator != (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(Slice<T, 2>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	dst.val_(1) += b;
	//dst += Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator + (const Slice<T, 2>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) + b;
	r[1] = a.val_(1) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator + (const A& a, const Slice<T, 2>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a + b.val_(0);
	r[1] = a + b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator + (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise +
{
	Slice<T, 2> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator + (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise +
{
	Slice<T, 2> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(Slice<T, 2>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	dst.val_(1) -= b;
	//dst -= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator - (const Slice<T, 2>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) - b;
	r[1] = a.val_(1) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator - (const A& a, const Slice<T, 2>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a - b.val_(0);
	r[1] = a - b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator - (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise -
{
	Slice<T, 2> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator - (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise -
{
	Slice<T, 2> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(Slice<T, 2>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	dst.val_(1) *= b;
	//dst *= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator * (const Slice<T, 2>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) * b;
	r[1] = a.val_(1) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator * (const A& a, const Slice<T, 2>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a * b.val_(0);
	r[1] = a * b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator * (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise *
{
	Slice<T, 2> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator * (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise *
{
	Slice<T, 2> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(Slice<T, 2>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	dst.val_(1) /= b;
	//dst /= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator / (const Slice<T, 2>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) / b;
	r[1] = a.val_(1) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator / (const A& a, const Slice<T, 2>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a / b.val_(0);
	r[1] = a / b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator / (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise /
{
	Slice<T, 2> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator / (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise /
{
	Slice<T, 2> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(Slice<T, 2>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	dst.val_(1) <<= b;
	//dst <<= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator << (const Slice<T, 2>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) << b;
	r[1] = a.val_(1) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator << (const A& a, const Slice<T, 2>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a << b.val_(0);
	r[1] = a << b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator << (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise <<
{
	Slice<T, 2> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator << (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise <<
{
	Slice<T, 2> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(Slice<T, 2>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	dst.val_(1) >>= b;
	//dst >>= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator >> (const Slice<T, 2>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) >> b;
	r[1] = a.val_(1) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator >> (const A& a, const Slice<T, 2>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a >> b.val_(0);
	r[1] = a >> b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator >> (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise >>
{
	Slice<T, 2> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator >> (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise >>
{
	Slice<T, 2> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(Slice<T, 2>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	dst.val_(1) %= b;
	//dst %= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator % (const Slice<T, 2>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) % b;
	r[1] = a.val_(1) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator % (const A& a, const Slice<T, 2>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a % b.val_(0);
	r[1] = a % b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator % (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise %
{
	Slice<T, 2> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator % (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise %
{
	Slice<T, 2> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(Slice<T, 2>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	dst.val_(1) |= b;
	//dst |= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator | (const Slice<T, 2>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) | b;
	r[1] = a.val_(1) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator | (const A& a, const Slice<T, 2>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a | b.val_(0);
	r[1] = a | b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator | (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise |
{
	Slice<T, 2> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator | (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise |
{
	Slice<T, 2> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(Slice<T, 2>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	dst.val_(1) &= b;
	//dst &= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator & (const Slice<T, 2>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) & b;
	r[1] = a.val_(1) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator & (const A& a, const Slice<T, 2>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a & b.val_(0);
	r[1] = a & b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator & (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise &
{
	Slice<T, 2> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator & (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise &
{
	Slice<T, 2> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(Slice<T, 2>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	dst.val_(1) ^= b;
	//dst ^= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator ^ (const Slice<T, 2>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) ^ b;
	r[1] = a.val_(1) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator ^ (const A& a, const Slice<T, 2>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a ^ b.val_(0);
	r[1] = a ^ b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator ^ (const Slice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise ^
{
	Slice<T, 2> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator ^ (const Slice<T, 2>& a, const Slice<T2, 2>& b)
// element wise ^
{
	Slice<T, 2> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void VecSliceAssign(VecSlice<T, 2>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
	dst[1] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 2> operator- (const VecSlice<T, 2>& src)
// return negative of all elements
{
	Slice<T, 2> r;
	r[0] = -src.val_(0);
	r[1] = -src.val_(1);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 2>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b &&
	a.val_(1) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 2> operator == (const VecSlice<T, 2>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b,
		a.val_(1) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 2> operator != (const VecSlice<T, 2>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b,
		a.val_(1) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator == (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator != (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator == (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 2> operator != (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(VecSlice<T, 2>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	dst.val_(1) += b;
	//dst += Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator + (const VecSlice<T, 2>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) + b;
	r[1] = a.val_(1) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator + (const A& a, const VecSlice<T, 2>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a + b.val_(0);
	r[1] = a + b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator + (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise +
{
	Slice<T, 2> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator + (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise +
{
	Slice<T, 2> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(VecSlice<T, 2>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	dst.val_(1) -= b;
	//dst -= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator - (const VecSlice<T, 2>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) - b;
	r[1] = a.val_(1) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator - (const A& a, const VecSlice<T, 2>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a - b.val_(0);
	r[1] = a - b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator - (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise -
{
	Slice<T, 2> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator - (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise -
{
	Slice<T, 2> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(VecSlice<T, 2>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	dst.val_(1) *= b;
	//dst *= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator * (const VecSlice<T, 2>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) * b;
	r[1] = a.val_(1) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator * (const A& a, const VecSlice<T, 2>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a * b.val_(0);
	r[1] = a * b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator * (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise *
{
	Slice<T, 2> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator * (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise *
{
	Slice<T, 2> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(VecSlice<T, 2>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	dst.val_(1) /= b;
	//dst /= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator / (const VecSlice<T, 2>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) / b;
	r[1] = a.val_(1) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator / (const A& a, const VecSlice<T, 2>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a / b.val_(0);
	r[1] = a / b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator / (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise /
{
	Slice<T, 2> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator / (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise /
{
	Slice<T, 2> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(VecSlice<T, 2>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	dst.val_(1) <<= b;
	//dst <<= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator << (const VecSlice<T, 2>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) << b;
	r[1] = a.val_(1) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator << (const A& a, const VecSlice<T, 2>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a << b.val_(0);
	r[1] = a << b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator << (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise <<
{
	Slice<T, 2> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator << (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise <<
{
	Slice<T, 2> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(VecSlice<T, 2>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	dst.val_(1) >>= b;
	//dst >>= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator >> (const VecSlice<T, 2>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) >> b;
	r[1] = a.val_(1) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator >> (const A& a, const VecSlice<T, 2>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a >> b.val_(0);
	r[1] = a >> b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator >> (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise >>
{
	Slice<T, 2> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator >> (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise >>
{
	Slice<T, 2> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(VecSlice<T, 2>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	dst.val_(1) %= b;
	//dst %= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator % (const VecSlice<T, 2>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) % b;
	r[1] = a.val_(1) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator % (const A& a, const VecSlice<T, 2>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a % b.val_(0);
	r[1] = a % b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator % (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise %
{
	Slice<T, 2> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator % (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise %
{
	Slice<T, 2> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(VecSlice<T, 2>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	dst.val_(1) |= b;
	//dst |= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator | (const VecSlice<T, 2>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) | b;
	r[1] = a.val_(1) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator | (const A& a, const VecSlice<T, 2>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a | b.val_(0);
	r[1] = a | b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator | (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise |
{
	Slice<T, 2> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator | (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise |
{
	Slice<T, 2> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(VecSlice<T, 2>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	dst.val_(1) &= b;
	//dst &= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator & (const VecSlice<T, 2>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) & b;
	r[1] = a.val_(1) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator & (const A& a, const VecSlice<T, 2>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a & b.val_(0);
	r[1] = a & b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator & (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise &
{
	Slice<T, 2> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator & (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise &
{
	Slice<T, 2> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(VecSlice<T, 2>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	dst.val_(1) ^= b;
	//dst ^= Slice<B, 2>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 2> operator ^ (const VecSlice<T, 2>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 2> r;
	r[0] = a.val_(0) ^ b;
	r[1] = a.val_(1) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 2> operator ^ (const A& a, const VecSlice<T, 2>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 2> r;
	r[0] = a ^ b.val_(0);
	r[1] = a ^ b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 2>& dst, const VecSlice<T2, 2>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator ^ (const VecSlice<T, 2>& a, const VecSlice<T2, 2>& b)
// element wise ^
{
	Slice<T, 2> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 2>& dst, const Slice<T2, 2>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 2> operator ^ (const VecSlice<T, 2>& a, const Slice<T2, 2>& b)
// element wise ^
{
	Slice<T, 2> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	return r;
}

//---------------------------------------------------------------------------------------------
template <class T, class T2/*Array or VecPtr*/>
	inline void VecPtrAssign(VecPtr<T, 3>& dst, T2& src, int offs)
// force a const (removal) cast to handle Array<T*> that returns const pointer reference
{
	dst.data[0] = src.data[0]+offs;
	dst.data[1] = src.data[1]+offs;
	dst.data[2] = src.data[2]+offs;
}

//---------------------------------------------------------------------------------------------
template <class T> inline Slice<T, 3> ToSlice(
	const T& arg_0,
	const T& arg_1,
	const T& arg_2
)
// take a variable number of arguments to generate a Slice
{
	Slice<T, 3> r;
	r[0] = arg_0;
	r[1] = arg_1;
	r[2] = arg_2;
	return r;
}


//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void SliceAssign(Slice<T, 3>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
	dst[1] = src;
	dst[2] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 3> operator- (const Slice<T, 3>& src)
// return negative of all elements
{
	Slice<T, 3> r;
	r[0] = -src.val_(0);
	r[1] = -src.val_(1);
	r[2] = -src.val_(2);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 3>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b &&
	a.val_(1) == b &&
	a.val_(2) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 3> operator == (const Slice<T, 3>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b,
		a.val_(1) == b,
		a.val_(2) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 3> operator != (const Slice<T, 3>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b,
		a.val_(1) != b,
		a.val_(2) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator == (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator != (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 3>& dst, const Slice<T2, 3>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 3>& a, const Slice<T2, 3>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator == (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator != (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(Slice<T, 3>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	dst.val_(1) += b;
	dst.val_(2) += b;
	//dst += Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator + (const Slice<T, 3>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) + b;
	r[1] = a.val_(1) + b;
	r[2] = a.val_(2) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator + (const A& a, const Slice<T, 3>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a + b.val_(0);
	r[1] = a + b.val_(1);
	r[2] = a + b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator + (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise +
{
	Slice<T, 3> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator + (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise +
{
	Slice<T, 3> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(Slice<T, 3>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	dst.val_(1) -= b;
	dst.val_(2) -= b;
	//dst -= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator - (const Slice<T, 3>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) - b;
	r[1] = a.val_(1) - b;
	r[2] = a.val_(2) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator - (const A& a, const Slice<T, 3>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a - b.val_(0);
	r[1] = a - b.val_(1);
	r[2] = a - b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator - (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise -
{
	Slice<T, 3> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator - (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise -
{
	Slice<T, 3> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(Slice<T, 3>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	dst.val_(1) *= b;
	dst.val_(2) *= b;
	//dst *= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator * (const Slice<T, 3>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) * b;
	r[1] = a.val_(1) * b;
	r[2] = a.val_(2) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator * (const A& a, const Slice<T, 3>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a * b.val_(0);
	r[1] = a * b.val_(1);
	r[2] = a * b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator * (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise *
{
	Slice<T, 3> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator * (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise *
{
	Slice<T, 3> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(Slice<T, 3>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	dst.val_(1) /= b;
	dst.val_(2) /= b;
	//dst /= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator / (const Slice<T, 3>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) / b;
	r[1] = a.val_(1) / b;
	r[2] = a.val_(2) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator / (const A& a, const Slice<T, 3>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a / b.val_(0);
	r[1] = a / b.val_(1);
	r[2] = a / b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator / (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise /
{
	Slice<T, 3> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator / (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise /
{
	Slice<T, 3> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(Slice<T, 3>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	dst.val_(1) <<= b;
	dst.val_(2) <<= b;
	//dst <<= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator << (const Slice<T, 3>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) << b;
	r[1] = a.val_(1) << b;
	r[2] = a.val_(2) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator << (const A& a, const Slice<T, 3>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a << b.val_(0);
	r[1] = a << b.val_(1);
	r[2] = a << b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator << (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise <<
{
	Slice<T, 3> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator << (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise <<
{
	Slice<T, 3> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(Slice<T, 3>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	dst.val_(1) >>= b;
	dst.val_(2) >>= b;
	//dst >>= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator >> (const Slice<T, 3>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) >> b;
	r[1] = a.val_(1) >> b;
	r[2] = a.val_(2) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator >> (const A& a, const Slice<T, 3>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a >> b.val_(0);
	r[1] = a >> b.val_(1);
	r[2] = a >> b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator >> (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise >>
{
	Slice<T, 3> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator >> (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise >>
{
	Slice<T, 3> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(Slice<T, 3>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	dst.val_(1) %= b;
	dst.val_(2) %= b;
	//dst %= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator % (const Slice<T, 3>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) % b;
	r[1] = a.val_(1) % b;
	r[2] = a.val_(2) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator % (const A& a, const Slice<T, 3>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a % b.val_(0);
	r[1] = a % b.val_(1);
	r[2] = a % b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator % (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise %
{
	Slice<T, 3> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator % (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise %
{
	Slice<T, 3> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(Slice<T, 3>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	dst.val_(1) |= b;
	dst.val_(2) |= b;
	//dst |= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator | (const Slice<T, 3>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) | b;
	r[1] = a.val_(1) | b;
	r[2] = a.val_(2) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator | (const A& a, const Slice<T, 3>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a | b.val_(0);
	r[1] = a | b.val_(1);
	r[2] = a | b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator | (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise |
{
	Slice<T, 3> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator | (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise |
{
	Slice<T, 3> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(Slice<T, 3>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	dst.val_(1) &= b;
	dst.val_(2) &= b;
	//dst &= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator & (const Slice<T, 3>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) & b;
	r[1] = a.val_(1) & b;
	r[2] = a.val_(2) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator & (const A& a, const Slice<T, 3>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a & b.val_(0);
	r[1] = a & b.val_(1);
	r[2] = a & b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator & (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise &
{
	Slice<T, 3> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator & (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise &
{
	Slice<T, 3> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(Slice<T, 3>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	dst.val_(1) ^= b;
	dst.val_(2) ^= b;
	//dst ^= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator ^ (const Slice<T, 3>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) ^ b;
	r[1] = a.val_(1) ^ b;
	r[2] = a.val_(2) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator ^ (const A& a, const Slice<T, 3>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a ^ b.val_(0);
	r[1] = a ^ b.val_(1);
	r[2] = a ^ b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator ^ (const Slice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise ^
{
	Slice<T, 3> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator ^ (const Slice<T, 3>& a, const Slice<T2, 3>& b)
// element wise ^
{
	Slice<T, 3> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void VecSliceAssign(VecSlice<T, 3>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
	dst[1] = src;
	dst[2] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 3> operator- (const VecSlice<T, 3>& src)
// return negative of all elements
{
	Slice<T, 3> r;
	r[0] = -src.val_(0);
	r[1] = -src.val_(1);
	r[2] = -src.val_(2);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 3>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b &&
	a.val_(1) == b &&
	a.val_(2) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 3> operator == (const VecSlice<T, 3>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b,
		a.val_(1) == b,
		a.val_(2) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 3> operator != (const VecSlice<T, 3>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b,
		a.val_(1) != b,
		a.val_(2) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator == (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator != (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator == (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 3> operator != (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(VecSlice<T, 3>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	dst.val_(1) += b;
	dst.val_(2) += b;
	//dst += Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator + (const VecSlice<T, 3>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) + b;
	r[1] = a.val_(1) + b;
	r[2] = a.val_(2) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator + (const A& a, const VecSlice<T, 3>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a + b.val_(0);
	r[1] = a + b.val_(1);
	r[2] = a + b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator + (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise +
{
	Slice<T, 3> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator + (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise +
{
	Slice<T, 3> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(VecSlice<T, 3>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	dst.val_(1) -= b;
	dst.val_(2) -= b;
	//dst -= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator - (const VecSlice<T, 3>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) - b;
	r[1] = a.val_(1) - b;
	r[2] = a.val_(2) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator - (const A& a, const VecSlice<T, 3>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a - b.val_(0);
	r[1] = a - b.val_(1);
	r[2] = a - b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator - (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise -
{
	Slice<T, 3> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator - (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise -
{
	Slice<T, 3> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(VecSlice<T, 3>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	dst.val_(1) *= b;
	dst.val_(2) *= b;
	//dst *= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator * (const VecSlice<T, 3>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) * b;
	r[1] = a.val_(1) * b;
	r[2] = a.val_(2) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator * (const A& a, const VecSlice<T, 3>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a * b.val_(0);
	r[1] = a * b.val_(1);
	r[2] = a * b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator * (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise *
{
	Slice<T, 3> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator * (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise *
{
	Slice<T, 3> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(VecSlice<T, 3>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	dst.val_(1) /= b;
	dst.val_(2) /= b;
	//dst /= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator / (const VecSlice<T, 3>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) / b;
	r[1] = a.val_(1) / b;
	r[2] = a.val_(2) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator / (const A& a, const VecSlice<T, 3>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a / b.val_(0);
	r[1] = a / b.val_(1);
	r[2] = a / b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator / (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise /
{
	Slice<T, 3> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator / (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise /
{
	Slice<T, 3> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(VecSlice<T, 3>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	dst.val_(1) <<= b;
	dst.val_(2) <<= b;
	//dst <<= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator << (const VecSlice<T, 3>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) << b;
	r[1] = a.val_(1) << b;
	r[2] = a.val_(2) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator << (const A& a, const VecSlice<T, 3>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a << b.val_(0);
	r[1] = a << b.val_(1);
	r[2] = a << b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator << (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise <<
{
	Slice<T, 3> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator << (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise <<
{
	Slice<T, 3> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(VecSlice<T, 3>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	dst.val_(1) >>= b;
	dst.val_(2) >>= b;
	//dst >>= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator >> (const VecSlice<T, 3>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) >> b;
	r[1] = a.val_(1) >> b;
	r[2] = a.val_(2) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator >> (const A& a, const VecSlice<T, 3>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a >> b.val_(0);
	r[1] = a >> b.val_(1);
	r[2] = a >> b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator >> (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise >>
{
	Slice<T, 3> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator >> (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise >>
{
	Slice<T, 3> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(VecSlice<T, 3>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	dst.val_(1) %= b;
	dst.val_(2) %= b;
	//dst %= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator % (const VecSlice<T, 3>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) % b;
	r[1] = a.val_(1) % b;
	r[2] = a.val_(2) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator % (const A& a, const VecSlice<T, 3>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a % b.val_(0);
	r[1] = a % b.val_(1);
	r[2] = a % b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator % (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise %
{
	Slice<T, 3> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator % (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise %
{
	Slice<T, 3> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(VecSlice<T, 3>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	dst.val_(1) |= b;
	dst.val_(2) |= b;
	//dst |= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator | (const VecSlice<T, 3>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) | b;
	r[1] = a.val_(1) | b;
	r[2] = a.val_(2) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator | (const A& a, const VecSlice<T, 3>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a | b.val_(0);
	r[1] = a | b.val_(1);
	r[2] = a | b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator | (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise |
{
	Slice<T, 3> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator | (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise |
{
	Slice<T, 3> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(VecSlice<T, 3>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	dst.val_(1) &= b;
	dst.val_(2) &= b;
	//dst &= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator & (const VecSlice<T, 3>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) & b;
	r[1] = a.val_(1) & b;
	r[2] = a.val_(2) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator & (const A& a, const VecSlice<T, 3>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a & b.val_(0);
	r[1] = a & b.val_(1);
	r[2] = a & b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator & (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise &
{
	Slice<T, 3> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator & (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise &
{
	Slice<T, 3> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(VecSlice<T, 3>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	dst.val_(1) ^= b;
	dst.val_(2) ^= b;
	//dst ^= Slice<B, 3>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 3> operator ^ (const VecSlice<T, 3>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 3> r;
	r[0] = a.val_(0) ^ b;
	r[1] = a.val_(1) ^ b;
	r[2] = a.val_(2) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 3> operator ^ (const A& a, const VecSlice<T, 3>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 3> r;
	r[0] = a ^ b.val_(0);
	r[1] = a ^ b.val_(1);
	r[2] = a ^ b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 3>& dst, const VecSlice<T2, 3>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator ^ (const VecSlice<T, 3>& a, const VecSlice<T2, 3>& b)
// element wise ^
{
	Slice<T, 3> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 3>& dst, const Slice<T2, 3>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 3> operator ^ (const VecSlice<T, 3>& a, const Slice<T2, 3>& b)
// element wise ^
{
	Slice<T, 3> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	return r;
}

//---------------------------------------------------------------------------------------------
template <class T, class T2/*Array or VecPtr*/>
	inline void VecPtrAssign(VecPtr<T, 4>& dst, T2& src, int offs)
// force a const (removal) cast to handle Array<T*> that returns const pointer reference
{
	dst.data[0] = src.data[0]+offs;
	dst.data[1] = src.data[1]+offs;
	dst.data[2] = src.data[2]+offs;
	dst.data[3] = src.data[3]+offs;
}

//---------------------------------------------------------------------------------------------
template <class T> inline Slice<T, 4> ToSlice(
	const T& arg_0,
	const T& arg_1,
	const T& arg_2,
	const T& arg_3
)
// take a variable number of arguments to generate a Slice
{
	Slice<T, 4> r;
	r[0] = arg_0;
	r[1] = arg_1;
	r[2] = arg_2;
	r[3] = arg_3;
	return r;
}


//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void SliceAssign(Slice<T, 4>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
	dst[1] = src;
	dst[2] = src;
	dst[3] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 4> operator- (const Slice<T, 4>& src)
// return negative of all elements
{
	Slice<T, 4> r;
	r[0] = -src.val_(0);
	r[1] = -src.val_(1);
	r[2] = -src.val_(2);
	r[3] = -src.val_(3);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 4>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b &&
	a.val_(1) == b &&
	a.val_(2) == b &&
	a.val_(3) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 4> operator == (const Slice<T, 4>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b,
		a.val_(1) == b,
		a.val_(2) == b,
		a.val_(3) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 4> operator != (const Slice<T, 4>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b,
		a.val_(1) != b,
		a.val_(2) != b,
		a.val_(3) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
	dst[3] = src.val_(3);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2) &&
	a.val_(3) == b.val_(3);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator == (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2),
		a.val_(3) == b.val_(3)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator != (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2),
		a.val_(3) != b.val_(3)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void SliceAssign(Slice<T, 4>& dst, const Slice<T2, 4>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
	dst[3] = src.val_(3);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const Slice<T, 4>& a, const Slice<T2, 4>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2) &&
	a.val_(3) == b.val_(3);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator == (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2),
		a.val_(3) == b.val_(3)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator != (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2),
		a.val_(3) != b.val_(3)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(Slice<T, 4>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	dst.val_(1) += b;
	dst.val_(2) += b;
	dst.val_(3) += b;
	//dst += Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator + (const Slice<T, 4>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) + b;
	r[1] = a.val_(1) + b;
	r[2] = a.val_(2) + b;
	r[3] = a.val_(3) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator + (const A& a, const Slice<T, 4>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a + b.val_(0);
	r[1] = a + b.val_(1);
	r[2] = a + b.val_(2);
	r[3] = a + b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
	dst.val_(3) += b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator + (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise +
{
	Slice<T, 4> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	r[3] = a.val_(3) + b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
	dst.val_(3) += b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator + (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise +
{
	Slice<T, 4> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	r[3] = a.val_(3) + b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(Slice<T, 4>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	dst.val_(1) -= b;
	dst.val_(2) -= b;
	dst.val_(3) -= b;
	//dst -= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator - (const Slice<T, 4>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) - b;
	r[1] = a.val_(1) - b;
	r[2] = a.val_(2) - b;
	r[3] = a.val_(3) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator - (const A& a, const Slice<T, 4>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a - b.val_(0);
	r[1] = a - b.val_(1);
	r[2] = a - b.val_(2);
	r[3] = a - b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
	dst.val_(3) -= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator - (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise -
{
	Slice<T, 4> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	r[3] = a.val_(3) - b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
	dst.val_(3) -= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator - (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise -
{
	Slice<T, 4> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	r[3] = a.val_(3) - b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(Slice<T, 4>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	dst.val_(1) *= b;
	dst.val_(2) *= b;
	dst.val_(3) *= b;
	//dst *= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator * (const Slice<T, 4>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) * b;
	r[1] = a.val_(1) * b;
	r[2] = a.val_(2) * b;
	r[3] = a.val_(3) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator * (const A& a, const Slice<T, 4>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a * b.val_(0);
	r[1] = a * b.val_(1);
	r[2] = a * b.val_(2);
	r[3] = a * b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
	dst.val_(3) *= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator * (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise *
{
	Slice<T, 4> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	r[3] = a.val_(3) * b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
	dst.val_(3) *= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator * (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise *
{
	Slice<T, 4> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	r[3] = a.val_(3) * b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(Slice<T, 4>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	dst.val_(1) /= b;
	dst.val_(2) /= b;
	dst.val_(3) /= b;
	//dst /= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator / (const Slice<T, 4>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) / b;
	r[1] = a.val_(1) / b;
	r[2] = a.val_(2) / b;
	r[3] = a.val_(3) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator / (const A& a, const Slice<T, 4>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a / b.val_(0);
	r[1] = a / b.val_(1);
	r[2] = a / b.val_(2);
	r[3] = a / b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
	dst.val_(3) /= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator / (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise /
{
	Slice<T, 4> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	r[3] = a.val_(3) / b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
	dst.val_(3) /= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator / (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise /
{
	Slice<T, 4> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	r[3] = a.val_(3) / b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(Slice<T, 4>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	dst.val_(1) <<= b;
	dst.val_(2) <<= b;
	dst.val_(3) <<= b;
	//dst <<= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator << (const Slice<T, 4>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) << b;
	r[1] = a.val_(1) << b;
	r[2] = a.val_(2) << b;
	r[3] = a.val_(3) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator << (const A& a, const Slice<T, 4>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a << b.val_(0);
	r[1] = a << b.val_(1);
	r[2] = a << b.val_(2);
	r[3] = a << b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
	dst.val_(3) <<= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator << (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise <<
{
	Slice<T, 4> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	r[3] = a.val_(3) << b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
	dst.val_(3) <<= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator << (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise <<
{
	Slice<T, 4> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	r[3] = a.val_(3) << b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(Slice<T, 4>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	dst.val_(1) >>= b;
	dst.val_(2) >>= b;
	dst.val_(3) >>= b;
	//dst >>= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator >> (const Slice<T, 4>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) >> b;
	r[1] = a.val_(1) >> b;
	r[2] = a.val_(2) >> b;
	r[3] = a.val_(3) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator >> (const A& a, const Slice<T, 4>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a >> b.val_(0);
	r[1] = a >> b.val_(1);
	r[2] = a >> b.val_(2);
	r[3] = a >> b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
	dst.val_(3) >>= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator >> (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise >>
{
	Slice<T, 4> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	r[3] = a.val_(3) >> b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
	dst.val_(3) >>= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator >> (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise >>
{
	Slice<T, 4> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	r[3] = a.val_(3) >> b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(Slice<T, 4>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	dst.val_(1) %= b;
	dst.val_(2) %= b;
	dst.val_(3) %= b;
	//dst %= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator % (const Slice<T, 4>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) % b;
	r[1] = a.val_(1) % b;
	r[2] = a.val_(2) % b;
	r[3] = a.val_(3) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator % (const A& a, const Slice<T, 4>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a % b.val_(0);
	r[1] = a % b.val_(1);
	r[2] = a % b.val_(2);
	r[3] = a % b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
	dst.val_(3) %= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator % (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise %
{
	Slice<T, 4> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	r[3] = a.val_(3) % b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
	dst.val_(3) %= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator % (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise %
{
	Slice<T, 4> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	r[3] = a.val_(3) % b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(Slice<T, 4>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	dst.val_(1) |= b;
	dst.val_(2) |= b;
	dst.val_(3) |= b;
	//dst |= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator | (const Slice<T, 4>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) | b;
	r[1] = a.val_(1) | b;
	r[2] = a.val_(2) | b;
	r[3] = a.val_(3) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator | (const A& a, const Slice<T, 4>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a | b.val_(0);
	r[1] = a | b.val_(1);
	r[2] = a | b.val_(2);
	r[3] = a | b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
	dst.val_(3) |= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator | (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise |
{
	Slice<T, 4> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	r[3] = a.val_(3) | b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
	dst.val_(3) |= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator | (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise |
{
	Slice<T, 4> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	r[3] = a.val_(3) | b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(Slice<T, 4>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	dst.val_(1) &= b;
	dst.val_(2) &= b;
	dst.val_(3) &= b;
	//dst &= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator & (const Slice<T, 4>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) & b;
	r[1] = a.val_(1) & b;
	r[2] = a.val_(2) & b;
	r[3] = a.val_(3) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator & (const A& a, const Slice<T, 4>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a & b.val_(0);
	r[1] = a & b.val_(1);
	r[2] = a & b.val_(2);
	r[3] = a & b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
	dst.val_(3) &= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator & (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise &
{
	Slice<T, 4> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	r[3] = a.val_(3) & b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
	dst.val_(3) &= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator & (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise &
{
	Slice<T, 4> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	r[3] = a.val_(3) & b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(Slice<T, 4>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	dst.val_(1) ^= b;
	dst.val_(2) ^= b;
	dst.val_(3) ^= b;
	//dst ^= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator ^ (const Slice<T, 4>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) ^ b;
	r[1] = a.val_(1) ^ b;
	r[2] = a.val_(2) ^ b;
	r[3] = a.val_(3) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator ^ (const A& a, const Slice<T, 4>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a ^ b.val_(0);
	r[1] = a ^ b.val_(1);
	r[2] = a ^ b.val_(2);
	r[3] = a ^ b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
	dst.val_(3) ^= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator ^ (const Slice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise ^
{
	Slice<T, 4> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	r[3] = a.val_(3) ^ b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(Slice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
	dst.val_(3) ^= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator ^ (const Slice<T, 4>& a, const Slice<T2, 4>& b)
// element wise ^
{
	Slice<T, 4> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	r[3] = a.val_(3) ^ b.val_(3);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class SRC> inline void VecSliceAssign(VecSlice<T, 4>& dst, const SRC& src)
// assign "src" to all elements
{
	dst[0] = src;
	dst[1] = src;
	dst[2] = src;
	dst[3] = src;
}
//-----------------------------------------------------------------------------------------
template<class T> inline Slice<T, 4> operator- (const VecSlice<T, 4>& src)
// return negative of all elements
{
	Slice<T, 4> r;
	r[0] = -src.val_(0);
	r[1] = -src.val_(1);
	r[2] = -src.val_(2);
	r[3] = -src.val_(3);
	return r;
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 4>& a, const T2& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b &&
	a.val_(1) == b &&
	a.val_(2) == b &&
	a.val_(3) == b;
}

//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 4> operator == (const VecSlice<T, 4>& a, const B& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b,
		a.val_(1) == b,
		a.val_(2) == b,
		a.val_(3) == b
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline Slice<bool, 4> operator != (const VecSlice<T, 4>& a, const B& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b,
		a.val_(1) != b,
		a.val_(2) != b,
		a.val_(3) != b
	);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
	dst[3] = src.val_(3);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2) &&
	a.val_(3) == b.val_(3);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator == (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2),
		a.val_(3) == b.val_(3)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator != (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2),
		a.val_(3) != b.val_(3)
	);
}
//-----------------------------------------------------------------------------------------
template<class T, class T2> inline void VecSliceAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& src)
// element-wise assign
{
	dst[0] = src.val_(0);
	dst[1] = src.val_(1);
	dst[2] = src.val_(2);
	dst[3] = src.val_(3);
}

//-----------------------------------------------------------------------------------------
template<class T, class T2> inline bool isIdentical(const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// return true if all elements in "a" have the same value as in "b"
{
	return
	a.val_(0) == b.val_(0) &&
	a.val_(1) == b.val_(1) &&
	a.val_(2) == b.val_(2) &&
	a.val_(3) == b.val_(3);
}

//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator == (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element-wise ==
{
	return ToSlice(
		a.val_(0) == b.val_(0),
		a.val_(1) == b.val_(1),
		a.val_(2) == b.val_(2),
		a.val_(3) == b.val_(3)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class T2> inline Slice<bool, 4> operator != (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element-wise !=
{
	return ToSlice(
		a.val_(0) != b.val_(0),
		a.val_(1) != b.val_(1),
		a.val_(2) != b.val_(2),
		a.val_(3) != b.val_(3)
	);
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AddAssign(VecSlice<T, 4>& dst, B b)
// apply += b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) += b;
	dst.val_(1) += b;
	dst.val_(2) += b;
	dst.val_(3) += b;
	//dst += Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator + (const VecSlice<T, 4>& a, const B& b)
// apply + b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) + b;
	r[1] = a.val_(1) + b;
	r[2] = a.val_(2) + b;
	r[3] = a.val_(3) + b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator + (const A& a, const VecSlice<T, 4>& b)
// apply a + on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a + b.val_(0);
	r[1] = a + b.val_(1);
	r[2] = a + b.val_(2);
	r[3] = a + b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
	dst.val_(3) += b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator + (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise +
{
	Slice<T, 4> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	r[3] = a.val_(3) + b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AddAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise +=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) += b.val_(0);
	dst.val_(1) += b.val_(1);
	dst.val_(2) += b.val_(2);
	dst.val_(3) += b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator + (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise +
{
	Slice<T, 4> r;
	r[0] = a.val_(0) + b.val_(0);
	r[1] = a.val_(1) + b.val_(1);
	r[2] = a.val_(2) + b.val_(2);
	r[3] = a.val_(3) + b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void SubtractAssign(VecSlice<T, 4>& dst, B b)
// apply -= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) -= b;
	dst.val_(1) -= b;
	dst.val_(2) -= b;
	dst.val_(3) -= b;
	//dst -= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator - (const VecSlice<T, 4>& a, const B& b)
// apply - b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) - b;
	r[1] = a.val_(1) - b;
	r[2] = a.val_(2) - b;
	r[3] = a.val_(3) - b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator - (const A& a, const VecSlice<T, 4>& b)
// apply a - on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a - b.val_(0);
	r[1] = a - b.val_(1);
	r[2] = a - b.val_(2);
	r[3] = a - b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
	dst.val_(3) -= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator - (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise -
{
	Slice<T, 4> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	r[3] = a.val_(3) - b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void SubtractAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise -=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) -= b.val_(0);
	dst.val_(1) -= b.val_(1);
	dst.val_(2) -= b.val_(2);
	dst.val_(3) -= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator - (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise -
{
	Slice<T, 4> r;
	r[0] = a.val_(0) - b.val_(0);
	r[1] = a.val_(1) - b.val_(1);
	r[2] = a.val_(2) - b.val_(2);
	r[3] = a.val_(3) - b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void MultiplyAssign(VecSlice<T, 4>& dst, B b)
// apply *= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) *= b;
	dst.val_(1) *= b;
	dst.val_(2) *= b;
	dst.val_(3) *= b;
	//dst *= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator * (const VecSlice<T, 4>& a, const B& b)
// apply * b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) * b;
	r[1] = a.val_(1) * b;
	r[2] = a.val_(2) * b;
	r[3] = a.val_(3) * b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator * (const A& a, const VecSlice<T, 4>& b)
// apply a * on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a * b.val_(0);
	r[1] = a * b.val_(1);
	r[2] = a * b.val_(2);
	r[3] = a * b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
	dst.val_(3) *= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator * (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise *
{
	Slice<T, 4> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	r[3] = a.val_(3) * b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void MultiplyAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise *=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) *= b.val_(0);
	dst.val_(1) *= b.val_(1);
	dst.val_(2) *= b.val_(2);
	dst.val_(3) *= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator * (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise *
{
	Slice<T, 4> r;
	r[0] = a.val_(0) * b.val_(0);
	r[1] = a.val_(1) * b.val_(1);
	r[2] = a.val_(2) * b.val_(2);
	r[3] = a.val_(3) * b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void DivideAssign(VecSlice<T, 4>& dst, B b)
// apply /= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) /= b;
	dst.val_(1) /= b;
	dst.val_(2) /= b;
	dst.val_(3) /= b;
	//dst /= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator / (const VecSlice<T, 4>& a, const B& b)
// apply / b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) / b;
	r[1] = a.val_(1) / b;
	r[2] = a.val_(2) / b;
	r[3] = a.val_(3) / b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator / (const A& a, const VecSlice<T, 4>& b)
// apply a / on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a / b.val_(0);
	r[1] = a / b.val_(1);
	r[2] = a / b.val_(2);
	r[3] = a / b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
	dst.val_(3) /= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator / (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise /
{
	Slice<T, 4> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	r[3] = a.val_(3) / b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void DivideAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise /=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) /= b.val_(0);
	dst.val_(1) /= b.val_(1);
	dst.val_(2) /= b.val_(2);
	dst.val_(3) /= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator / (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise /
{
	Slice<T, 4> r;
	r[0] = a.val_(0) / b.val_(0);
	r[1] = a.val_(1) / b.val_(1);
	r[2] = a.val_(2) / b.val_(2);
	r[3] = a.val_(3) / b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void LeftShiftAssign(VecSlice<T, 4>& dst, B b)
// apply <<= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) <<= b;
	dst.val_(1) <<= b;
	dst.val_(2) <<= b;
	dst.val_(3) <<= b;
	//dst <<= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator << (const VecSlice<T, 4>& a, const B& b)
// apply << b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) << b;
	r[1] = a.val_(1) << b;
	r[2] = a.val_(2) << b;
	r[3] = a.val_(3) << b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator << (const A& a, const VecSlice<T, 4>& b)
// apply a << on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a << b.val_(0);
	r[1] = a << b.val_(1);
	r[2] = a << b.val_(2);
	r[3] = a << b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
	dst.val_(3) <<= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator << (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise <<
{
	Slice<T, 4> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	r[3] = a.val_(3) << b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void LeftShiftAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise <<=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) <<= b.val_(0);
	dst.val_(1) <<= b.val_(1);
	dst.val_(2) <<= b.val_(2);
	dst.val_(3) <<= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator << (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise <<
{
	Slice<T, 4> r;
	r[0] = a.val_(0) << b.val_(0);
	r[1] = a.val_(1) << b.val_(1);
	r[2] = a.val_(2) << b.val_(2);
	r[3] = a.val_(3) << b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void RightShiftAssign(VecSlice<T, 4>& dst, B b)
// apply >>= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) >>= b;
	dst.val_(1) >>= b;
	dst.val_(2) >>= b;
	dst.val_(3) >>= b;
	//dst >>= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator >> (const VecSlice<T, 4>& a, const B& b)
// apply >> b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) >> b;
	r[1] = a.val_(1) >> b;
	r[2] = a.val_(2) >> b;
	r[3] = a.val_(3) >> b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator >> (const A& a, const VecSlice<T, 4>& b)
// apply a >> on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a >> b.val_(0);
	r[1] = a >> b.val_(1);
	r[2] = a >> b.val_(2);
	r[3] = a >> b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
	dst.val_(3) >>= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator >> (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise >>
{
	Slice<T, 4> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	r[3] = a.val_(3) >> b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void RightShiftAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise >>=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) >>= b.val_(0);
	dst.val_(1) >>= b.val_(1);
	dst.val_(2) >>= b.val_(2);
	dst.val_(3) >>= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator >> (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise >>
{
	Slice<T, 4> r;
	r[0] = a.val_(0) >> b.val_(0);
	r[1] = a.val_(1) >> b.val_(1);
	r[2] = a.val_(2) >> b.val_(2);
	r[3] = a.val_(3) >> b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void ModuloAssign(VecSlice<T, 4>& dst, B b)
// apply %= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) %= b;
	dst.val_(1) %= b;
	dst.val_(2) %= b;
	dst.val_(3) %= b;
	//dst %= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator % (const VecSlice<T, 4>& a, const B& b)
// apply % b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) % b;
	r[1] = a.val_(1) % b;
	r[2] = a.val_(2) % b;
	r[3] = a.val_(3) % b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator % (const A& a, const VecSlice<T, 4>& b)
// apply a % on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a % b.val_(0);
	r[1] = a % b.val_(1);
	r[2] = a % b.val_(2);
	r[3] = a % b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
	dst.val_(3) %= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator % (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise %
{
	Slice<T, 4> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	r[3] = a.val_(3) % b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void ModuloAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise %=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) %= b.val_(0);
	dst.val_(1) %= b.val_(1);
	dst.val_(2) %= b.val_(2);
	dst.val_(3) %= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator % (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise %
{
	Slice<T, 4> r;
	r[0] = a.val_(0) % b.val_(0);
	r[1] = a.val_(1) % b.val_(1);
	r[2] = a.val_(2) % b.val_(2);
	r[3] = a.val_(3) % b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void OrAssign(VecSlice<T, 4>& dst, B b)
// apply |= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) |= b;
	dst.val_(1) |= b;
	dst.val_(2) |= b;
	dst.val_(3) |= b;
	//dst |= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator | (const VecSlice<T, 4>& a, const B& b)
// apply | b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) | b;
	r[1] = a.val_(1) | b;
	r[2] = a.val_(2) | b;
	r[3] = a.val_(3) | b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator | (const A& a, const VecSlice<T, 4>& b)
// apply a | on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a | b.val_(0);
	r[1] = a | b.val_(1);
	r[2] = a | b.val_(2);
	r[3] = a | b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
	dst.val_(3) |= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator | (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise |
{
	Slice<T, 4> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	r[3] = a.val_(3) | b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void OrAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise |=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) |= b.val_(0);
	dst.val_(1) |= b.val_(1);
	dst.val_(2) |= b.val_(2);
	dst.val_(3) |= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator | (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise |
{
	Slice<T, 4> r;
	r[0] = a.val_(0) | b.val_(0);
	r[1] = a.val_(1) | b.val_(1);
	r[2] = a.val_(2) | b.val_(2);
	r[3] = a.val_(3) | b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void AndAssign(VecSlice<T, 4>& dst, B b)
// apply &= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) &= b;
	dst.val_(1) &= b;
	dst.val_(2) &= b;
	dst.val_(3) &= b;
	//dst &= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator & (const VecSlice<T, 4>& a, const B& b)
// apply & b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) & b;
	r[1] = a.val_(1) & b;
	r[2] = a.val_(2) & b;
	r[3] = a.val_(3) & b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator & (const A& a, const VecSlice<T, 4>& b)
// apply a & on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a & b.val_(0);
	r[1] = a & b.val_(1);
	r[2] = a & b.val_(2);
	r[3] = a & b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
	dst.val_(3) &= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator & (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise &
{
	Slice<T, 4> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	r[3] = a.val_(3) & b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void AndAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise &=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) &= b.val_(0);
	dst.val_(1) &= b.val_(1);
	dst.val_(2) &= b.val_(2);
	dst.val_(3) &= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator & (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise &
{
	Slice<T, 4> r;
	r[0] = a.val_(0) & b.val_(0);
	r[1] = a.val_(1) & b.val_(1);
	r[2] = a.val_(2) & b.val_(2);
	r[3] = a.val_(3) & b.val_(3);
	return r;
}
//-------------------------------------------------------------------------------------
template<class T, class B> inline void XorAssign(VecSlice<T, 4>& dst, B b)
// apply ^= b on all elements of a, take a copy of "b" in case it is an element from "dst"
{
	dst.val_(0) ^= b;
	dst.val_(1) ^= b;
	dst.val_(2) ^= b;
	dst.val_(3) ^= b;
	//dst ^= Slice<B, 4>(b); // sometimes this one produces faster code
}

//-------------------------------------------------------------------------------------
template <class T, class B> inline Slice<T, 4> operator ^ (const VecSlice<T, 4>& a, const B& b)
// apply ^ b on all elements of a
{
	Slice<T, 4> r;
	r[0] = a.val_(0) ^ b;
	r[1] = a.val_(1) ^ b;
	r[2] = a.val_(2) ^ b;
	r[3] = a.val_(3) ^ b;
	return r;
}
//-------------------------------------------------------------------------------------
template <class T, class A> inline Slice<A, 4> operator ^ (const A& a, const VecSlice<T, 4>& b)
// apply a ^ on all elements of b, assume return type should match "A"
{
	Slice<A, 4> r;
	r[0] = a ^ b.val_(0);
	r[1] = a ^ b.val_(1);
	r[2] = a ^ b.val_(2);
	r[3] = a ^ b.val_(3);
	return r;
}

//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 4>& dst, const VecSlice<T2, 4>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
	dst.val_(3) ^= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator ^ (const VecSlice<T, 4>& a, const VecSlice<T2, 4>& b)
// element wise ^
{
	Slice<T, 4> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	r[3] = a.val_(3) ^ b.val_(3);
	return r;
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline void XorAssign(VecSlice<T, 4>& dst, const Slice<T2, 4>& b)
// element wise ^=, note, this will work ok even if dst & b are the same object
{
	dst.val_(0) ^= b.val_(0);
	dst.val_(1) ^= b.val_(1);
	dst.val_(2) ^= b.val_(2);
	dst.val_(3) ^= b.val_(3);
}
//---------------------------------------------------------------------------------
template <class T, class T2> inline Slice<T, 4> operator ^ (const VecSlice<T, 4>& a, const Slice<T2, 4>& b)
// element wise ^
{
	Slice<T, 4> r;
	r[0] = a.val_(0) ^ b.val_(0);
	r[1] = a.val_(1) ^ b.val_(1);
	r[2] = a.val_(2) ^ b.val_(2);
	r[3] = a.val_(3) ^ b.val_(3);
	return r;
}

#if 0
//-------------------------------------------------------------------------------------------------
// unfortunately all of the loop processing stuff runs slower than doing manual loops otherwise
// it would be quite nice except for silly type promotion problems
//
namespace LoopProcess
{
	template <class LOOP, class ARG, class RET> struct Foreach1;

	struct Add {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) + b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst += src; }
	};
	struct Subtract {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) - b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst -= src; }
	};
	struct Multiply {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) * b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst *= src; }
	};
	struct Divide {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) / b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst /= src; }
	};
	struct LeftShift {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) << b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst <<= src; }
	};
	struct RightShift {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) >> b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst >>= src; }
	};
	struct Modulo {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) % b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst %= src; }
	};
	struct Or {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) | b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst |= src; }
	};
	struct And {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) & b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst &= src; }
	};
	struct Xor {
		template <class DST, class A, class B> __inline static DST get(const int& i, const A& a, const B& b) { return a.get<DST>(i) ^ b.get<DST>(i); }
		template <class DST, class SRC> __inline static void assign(DST& dst, const SRC& src) { dst ^= src; }
	};
	struct Assign {
		template <class DST, class SRC> static __inline void assign(DST& dst, const SRC& src) { dst = src; }
	};

	template <class A, class B, class OP> struct BinaryOp
	{
		A a;
		B b;
		template <class A2, class B2> __inline BinaryOp(const A2& a_, const B2& b_) : a(a_), b(b_) {}
		template <class R> __inline R get(const int& i) const { return OP::template get<R>(i, a, b); }
	};

	template <class T> struct Single
	{
		T t;
		template <class T2> __inline Single(const T2& t_):  t(t_) { }
		template <class T2/*ignored*/> __inline const T& get(const int& i) const { return t; }
	};


	struct LoopFwd { __inline static int get(const int& i) { return i; } };
	struct LoopRev { __inline static int get(const int& i) { return -i; } };

	template <class ARRAY_T, class GET_EL_T, class DIR> struct Loop
	{
		ARRAY_T data;
		__inline Loop(const ARRAY_T& data_) : data(data_) { }
		template <class R/*ignored*/> __inline GET_EL_T get(const int& i) const { return data[DIR::get(i)]; }
	};

	template <
		class ARRAY_T,
		class GET_EL_T,
		class OP_EL_T,
		class DIR
	>
		struct LoopAssign : public Loop<ARRAY_T, GET_EL_T, DIR>
	{
		typedef Loop<ARRAY_T, GET_EL_T, DIR> base;

		int n;

		__inline LoopAssign(const ARRAY_T& data_, int n_) : base(data_), n(n_) { }

		// do element wise operator assign
		template <class OP, class SRC> __inline LoopAssign& run(const SRC& src)
		{
			for(int i = 0; i < n; i++) OP::assign(base::data[DIR::get(i)], src.template get<OP_EL_T>(i));
			return *this;
		}
	
		template <class SRC> __inline LoopAssign& operator= (const SRC& src) { return run<Assign>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator= (const BinaryOp<A, B, OP>& src) { return run<Assign>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Assign>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Assign>(src); }
		template <class SRC> __inline LoopAssign& operator+= (const SRC& src) { return run<Add>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator+= (const BinaryOp<A, B, OP>& src) { return run<Add>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator+= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Add>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator+= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Add>(src); }
		template <class SRC> __inline LoopAssign& operator-= (const SRC& src) { return run<Subtract>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator-= (const BinaryOp<A, B, OP>& src) { return run<Subtract>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator-= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Subtract>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator-= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Subtract>(src); }
		template <class SRC> __inline LoopAssign& operator*= (const SRC& src) { return run<Multiply>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator*= (const BinaryOp<A, B, OP>& src) { return run<Multiply>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator*= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Multiply>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator*= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Multiply>(src); }
		template <class SRC> __inline LoopAssign& operator/= (const SRC& src) { return run<Divide>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator/= (const BinaryOp<A, B, OP>& src) { return run<Divide>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator/= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Divide>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator/= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Divide>(src); }
		template <class SRC> __inline LoopAssign& operator<<= (const SRC& src) { return run<LeftShift>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator<<= (const BinaryOp<A, B, OP>& src) { return run<LeftShift>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator<<= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<LeftShift>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator<<= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<LeftShift>(src); }
		template <class SRC> __inline LoopAssign& operator>>= (const SRC& src) { return run<RightShift>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator>>= (const BinaryOp<A, B, OP>& src) { return run<RightShift>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator>>= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<RightShift>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator>>= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<RightShift>(src); }
		template <class SRC> __inline LoopAssign& operator%= (const SRC& src) { return run<Modulo>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator%= (const BinaryOp<A, B, OP>& src) { return run<Modulo>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator%= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Modulo>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator%= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Modulo>(src); }
		template <class SRC> __inline LoopAssign& operator|= (const SRC& src) { return run<Or>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator|= (const BinaryOp<A, B, OP>& src) { return run<Or>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator|= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Or>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator|= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Or>(src); }
		template <class SRC> __inline LoopAssign& operator&= (const SRC& src) { return run<And>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator&= (const BinaryOp<A, B, OP>& src) { return run<And>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator&= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<And>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator&= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<And>(src); }
		template <class SRC> __inline LoopAssign& operator^= (const SRC& src) { return run<Xor>(Single<SRC>(src)); }
		template <class A, class B, class OP> __inline LoopAssign& operator^= (const BinaryOp<A, B, OP>& src) { return run<Xor>(src); }
		template <class ARRAY_T2, class GET_EL_T2, class DIR2> __inline LoopAssign& operator^= (const Loop<ARRAY_T2, GET_EL_T2, DIR2>& src) { return run<Xor>(src); }
		template <class LOOP2, class ARG2, class RET2> __inline LoopAssign& operator^= (const Foreach1<LOOP2, ARG2, RET2>& src) { return run<Xor>(src); }
	};

	template <class LOOP, class ARG, class RET> struct Foreach1
	{
		typedef RET (*FN)(const ARG&);
		FN fn;
		LOOP loop;
		__inline Foreach1(FN fn_, const LOOP& loop_): fn(fn_), loop(loop_) { }
		template <class T2/*ignored*/> __inline const RET get(const int& i) const { return (*fn)(loop.get<ARG>(i)); }
	};

};

template <class T> __inline LoopProcess::Single<T> Single(const T& t) { return LoopProcess::Single<T>(t); }



template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >
		operator + (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >
		operator + (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >
		operator + (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >
		operator + (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >
		operator + (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >
		operator + (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >
		operator + (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >
		operator + (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >
		operator + (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >
		operator + (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >
		operator + (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >
		operator + (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >
		operator + (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Add >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >
		operator + (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Add >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >
		operator + (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Add >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Add >
		operator + (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Add >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >
		operator - (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >
		operator - (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >
		operator - (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >
		operator - (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >
		operator - (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >
		operator - (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >
		operator - (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >
		operator - (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >
		operator - (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >
		operator - (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >
		operator - (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >
		operator - (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >
		operator - (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >
		operator - (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >
		operator - (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Subtract >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Subtract >
		operator - (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Subtract >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >
		operator * (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >
		operator * (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >
		operator * (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >
		operator * (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >
		operator * (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >
		operator * (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >
		operator * (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >
		operator * (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >
		operator * (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >
		operator * (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >
		operator * (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >
		operator * (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >
		operator * (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >
		operator * (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >
		operator * (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Multiply >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Multiply >
		operator * (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Multiply >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >
		operator / (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >
		operator / (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >
		operator / (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >
		operator / (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >
		operator / (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >
		operator / (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >
		operator / (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >
		operator / (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >
		operator / (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >
		operator / (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >
		operator / (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >
		operator / (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >
		operator / (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Divide >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >
		operator / (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Divide >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >
		operator / (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Divide >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Divide >
		operator / (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Divide >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >
		operator << (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >
		operator << (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >
		operator << (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >
		operator << (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >
		operator << (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >
		operator << (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::LeftShift >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::LeftShift >
		operator << (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::LeftShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >
		operator >> (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >
		operator >> (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >
		operator >> (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >
		operator >> (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >
		operator >> (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >
		operator >> (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::RightShift >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::RightShift >
		operator >> (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::RightShift >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >
		operator % (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >
		operator % (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >
		operator % (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >
		operator % (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >
		operator % (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >
		operator % (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >
		operator % (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >
		operator % (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >
		operator % (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >
		operator % (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >
		operator % (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >
		operator % (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >
		operator % (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >
		operator % (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >
		operator % (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Modulo >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Modulo >
		operator % (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Modulo >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >
		operator | (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >
		operator | (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >
		operator | (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >
		operator | (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >
		operator | (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >
		operator | (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >
		operator | (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >
		operator | (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >
		operator | (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >
		operator | (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >
		operator | (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >
		operator | (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >
		operator | (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Or >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >
		operator | (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Or >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >
		operator | (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Or >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Or >
		operator | (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Or >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >
		operator & (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >
		operator & (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >
		operator & (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >
		operator & (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >
		operator & (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >
		operator & (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >
		operator & (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >
		operator & (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >
		operator & (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >
		operator & (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >
		operator & (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >
		operator & (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >
		operator & (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::And >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >
		operator & (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::And >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >
		operator & (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::And >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::And >
		operator & (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::And >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class AARRAY_T, class AGET_EL_T, class ADIR, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Loop<AARRAY_T, AGET_EL_T, ADIR>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class AA, class AB, class AOP, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >
		operator ^ (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >(a, b);
}
template <class AA, class AB, class AOP, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >
		operator ^ (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >(a, b);
}
template <class AA, class AB, class AOP, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >
		operator ^ (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class AA, class AB, class AOP, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::BinaryOp<AA, AB, AOP>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::BinaryOp<AA, AB, AOP>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class ALOOP, class AARG, class ARET, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Foreach1<ALOOP, AARG, ARET>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Foreach1<ALOOP, AARG, ARET>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Single<AT>& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Single<AT>& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Single<AT>& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Single<AT>& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const LoopProcess::Single<AT>& a, const BT& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}
template <class AT, class BARRAY_T, class BGET_EL_T, class BDIR>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >
		operator ^ (const AT& a, const LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Loop<BARRAY_T, BGET_EL_T, BDIR>, LoopProcess::Xor >(a, b);
}
template <class AT, class BA, class BB, class BOP>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >
		operator ^ (const AT& a, const LoopProcess::BinaryOp<BA, BB, BOP>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::BinaryOp<BA, BB, BOP>, LoopProcess::Xor >(a, b);
}
template <class AT, class BLOOP, class BARG, class BRET>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >
		operator ^ (const AT& a, const LoopProcess::Foreach1<BLOOP, BARG, BRET>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Foreach1<BLOOP, BARG, BRET>, LoopProcess::Xor >(a, b);
}
template <class AT, class BT>
	__inline LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Xor >
		operator ^ (const AT& a, const LoopProcess::Single<BT>& b)
{
	return LoopProcess::BinaryOp<LoopProcess::Single<AT>, LoopProcess::Single<BT>, LoopProcess::Xor >(a, b);
}


// lvalue or rvalue: Fwd VecPtr<T, CH> (operation type VecSlice<T, CH>, get type Slice<T, CH>)
template <class T, int CH>
	__inline LoopProcess::LoopAssign<VecPtr<T, CH>, VecSlice<T, CH>, Slice<T, CH>, LoopProcess::LoopFwd >
		Fwd(const VecPtr<T, CH>& data, int n)
			{ return LoopProcess::LoopAssign<VecPtr<T, CH>, VecSlice<T, CH>, Slice<T, CH>, LoopProcess::LoopFwd >(data, n); }

// rvalue only: Fwd VecPtr<T, CH> (get type VecSlice<T, CH>)
template <class T, int CH>
	__inline LoopProcess::Loop<VecPtr<T, CH>, VecSlice<T, CH>, LoopProcess::LoopFwd >
		Fwd(const VecPtr<T, CH>& data)
			{ return LoopProcess::Loop<VecPtr<T, CH>, VecSlice<T, CH>, LoopProcess::LoopFwd >(data); }

// lvalue or rvalue: Fwd T* (operation type T, get type T)
template <class T>
	__inline LoopProcess::LoopAssign<T*, T, T, LoopProcess::LoopFwd >
		Fwd(const T*& data, int n)
			{ return LoopProcess::LoopAssign<T*, T, T, LoopProcess::LoopFwd >(data, n); }

// rvalue only: Fwd T* (get type T)
template <class T>
	__inline LoopProcess::Loop<T*, T, LoopProcess::LoopFwd >
		Fwd(const T*& data)
			{ return LoopProcess::Loop<T*, T, LoopProcess::LoopFwd >(data); }

// lvalue or rvalue: Rev VecPtr<T, CH> (operation type VecSlice<T, CH>, get type Slice<T, CH>)
template <class T, int CH>
	__inline LoopProcess::LoopAssign<VecPtr<T, CH>, VecSlice<T, CH>, Slice<T, CH>, LoopProcess::LoopRev >
		Rev(const VecPtr<T, CH>& data, int n)
			{ return LoopProcess::LoopAssign<VecPtr<T, CH>, VecSlice<T, CH>, Slice<T, CH>, LoopProcess::LoopRev >(data, n); }

// rvalue only: Rev VecPtr<T, CH> (get type VecSlice<T, CH>)
template <class T, int CH>
	__inline LoopProcess::Loop<VecPtr<T, CH>, VecSlice<T, CH>, LoopProcess::LoopRev >
		Rev(const VecPtr<T, CH>& data)
			{ return LoopProcess::Loop<VecPtr<T, CH>, VecSlice<T, CH>, LoopProcess::LoopRev >(data); }

// lvalue or rvalue: Rev T* (operation type T, get type T)
template <class T>
	__inline LoopProcess::LoopAssign<T*, T, T, LoopProcess::LoopRev >
		Rev(const T*& data, int n)
			{ return LoopProcess::LoopAssign<T*, T, T, LoopProcess::LoopRev >(data, n); }

// rvalue only: Rev T* (get type T)
template <class T>
	__inline LoopProcess::Loop<T*, T, LoopProcess::LoopRev >
		Rev(const T*& data)
			{ return LoopProcess::Loop<T*, T, LoopProcess::LoopRev >(data); }


template <class LOOP, class ARG, class RET>
	__inline LoopProcess::Foreach1<LOOP, ARG, RET> Foreach(RET (*fn)(const ARG&), const LOOP& loop)
		{ return LoopProcess::Foreach1<LOOP, ARG, RET>(fn, loop); }
#endif

#endif
